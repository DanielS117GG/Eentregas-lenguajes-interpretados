<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<title>Juego del Caballero</title>
<style>
  body, html { margin: 0; padding: 0; overflow: hidden; background: #cce0ff; font-family: Arial, sans-serif; }
  #gameCanvas { background: #7ec850; display: block; margin: 0 auto; }
  #scoreBoard { text-align: center; font-size: 24px; margin: 10px; }
  #gameOverScreen { display: none; text-align: center; font-size: 28px; }
  button { padding: 10px 20px; font-size: 20px; cursor: pointer; }
</style>
</head>
<body>
<div id="scoreBoard">
  Puntuaci√≥n: <span id="score">0</span> | Vidas: <span id="lives">3</span> | Mejor: <span id="bestScore">0</span>
</div>
<canvas id="gameCanvas" width="800" height="200"></canvas>
<div id="gameOverScreen">
  <p>Game Over</p>
  <button id="retryBtn">Reintentar</button>
</div>

<script>
(() => {
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  const scoreEl = document.getElementById('score');
  const livesEl = document.getElementById('lives');
  const bestScoreEl = document.getElementById('bestScore');
  const gameOverScreen = document.getElementById('gameOverScreen');
  const retryBtn = document.getElementById('retryBtn');

  const groundY = 150;
  const gravity = 0.6;
  const initialSpeed = 4;
  const speedIncrement = 1;
  const speedIncreaseInterval = 100; // puntos

  let speed = initialSpeed;
  let score = 0;
  let lives = 3;
  let bestScore = localStorage.getItem('bestScore') || 0;

  bestScoreEl.textContent = bestScore;

  class Knight {
    constructor() {
      this.width = 40;
      this.height = 60;
      this.x = 50;
      this.y = groundY - this.height;
      this.dy = 0;
      this.jumping = false;
    }
    draw() {
      // Dibujar caballero: cuerpo simple (puedes reemplazar con imagen)
      ctx.fillStyle = '#3a375f';
      ctx.fillRect(this.x, this.y, this.width, this.height);
      // Casco
      ctx.fillStyle = '#555';
      ctx.fillRect(this.x + 10, this.y - 10, 20, 15);
    }
    update() {
      if (this.jumping) {
        this.dy += gravity;
        this.y += this.dy;
        if (this.y >= groundY - this.height) {
          this.y = groundY - this.height;
          this.jumping = false;
          this.dy = 0;
        }
      }
    }
    jump() {
      if (!this.jumping) {
        this.jumping = true;
        this.dy = -12;
      }
    }
  }

  class Fireball {
    constructor() {
      this.radius = 15;
      this.x = canvas.width;
      this.y = groundY - this.radius;
      this.passed = false;
    }
    draw() {
      ctx.beginPath();
      ctx.fillStyle = '#ff4500';
      ctx.shadowColor = 'orange';
      ctx.shadowBlur = 10;
      ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
    }
    update() {
      this.x -= speed;
    }
  }

  let knight = new Knight();
  let fireballs = [];
  let frameCount = 0;

  function spawnFireball() {
    let fb = new Fireball();
    fireballs.push(fb);
  }

  function resetGame() {
    score = 0;
    lives = 3;
    speed = initialSpeed;
    fireballs = [];
    knight = new Knight();
    gameOverScreen.style.display = 'none';
    scoreEl.textContent = score;
    livesEl.textContent = lives;
    bestScoreEl.textContent = bestScore;
    requestAnimationFrame(gameLoop);
  }

  function gameOver() {
    if (score > bestScore) {
      bestScore = score;
      localStorage.setItem('bestScore', bestScore);
      bestScoreEl.textContent = bestScore;
    }
    gameOverScreen.style.display = 'block';
  }

  function detectCollision(rectX, rectY, rectW, rectH, circleX, circleY, radius) {
    // Simple AABB-circular collision detection
    let distX = Math.abs(circleX - rectX - rectW / 2);
    let distY = Math.abs(circleY - rectY - rectH / 2);

    if (distX > (rectW / 2 + radius)) { return false; }
    if (distY > (rectH / 2 + radius)) { return false; }

    if (distX <= (rectW / 2)) { return true; }
    if (distY <= (rectH / 2)) { return true; }

    let dx = distX - rectW / 2;
    let dy = distY - rectH / 2;
    return (dx * dx + dy * dy <= (radius * radius));
  }

  function update() {
    frameCount++;
    knight.update();

    if (frameCount % 90 === 0) spawnFireball();

    fireballs.forEach((fb, index) => {
      fb.update();

      if (!fb.passed && fb.x + fb.radius < knight.x) {
        fb.passed = true;
        score++;
        scoreEl.textContent = score;

        if (score % speedIncreaseInterval === 0) {
          speed += speedIncrement;
        }
      }

      if (detectCollision(knight.x, knight.y, knight.width, knight.height, fb.x, fb.y, fb.radius)) {
        fireballs.splice(index, 1);
        lives--;
        livesEl.textContent = lives;
        if (lives <= 0) {
          cancelAnimationFrame(animationId);
          gameOver();
        }
      }

      if (fb.x + fb.radius < 0) {
        fireballs.splice(index, 1);
      }
    });
  }

  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Tierra plana
    ctx.fillStyle = '#654321';
    ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);

    knight.draw();

    fireballs.forEach(fb => fb.draw());
  }

  let animationId;
  function gameLoop() {
    update();
    draw();
    if (lives > 0) {
      animationId = requestAnimationFrame(gameLoop);
    }
  }

  // Control de salto con teclado (espacio o flecha arriba)
  window.addEventListener('keydown', e => {
    if ((e.code === 'Space' || e.code === 'ArrowUp') && lives > 0) {
      knight.jump();
    }
  });

  retryBtn.addEventListener('click', () => {
    resetGame();
  });

  // Inicio juego
  resetGame();
})();
</script>
</body>
</html>
